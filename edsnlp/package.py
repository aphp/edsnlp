import os
import re
import shutil
import sys
import tempfile
import warnings
from pathlib import Path
from typing import TYPE_CHECKING, Any, Dict, Mapping, Optional, Sequence, Union

import build
import confit
import setuptools
import toml
from build.__main__ import build_package, build_package_via_sdist
from confit import Cli
from loguru import logger
from typing_extensions import Literal

import edsnlp
from edsnlp.utils.typing import AsList, Validated

logger.remove()
logger.add(
    sys.stdout,
    format="<green>{time:YYYY-MM-DD HH:mm:ss}</green> - <level>{level: <8}</level>"
    " - {message}",
)
py_version = f"{sys.version_info.major}.{sys.version_info.minor}"

app = Cli(pretty_exceptions_show_locals=False, pretty_exceptions_enable=False)


def snake_case(s):
    # From https://www.w3resource.com/python-exercises/string/python-data-type-string-exercise-97.php  # noqa E501
    return "_".join(
        re.sub(
            "([A-Z][a-z]+)", r" \1", re.sub("([A-Z]+)", r" \1", s.replace("-", " "))
        ).split()
    ).lower()


class ModuleName(str, Validated):
    def __new__(cls, *args, **kwargs):
        raise NotImplementedError("ModuleName is only meant for typing.")

    @classmethod
    def validate(cls, value, config=None):
        if not isinstance(value, str):
            raise TypeError("string required")

        if not re.match(
            r"^([A-Z0-9]|[A-Z0-9][A-Z0-9._-]*[A-Z0-9])$", value, flags=re.IGNORECASE
        ):
            raise ValueError("invalid identifier")
        return value


if TYPE_CHECKING:
    ModuleName = str  # noqa F811


INIT_PY = """
# -----------------------------------------
# This section was autogenerated by edsnlp
# -----------------------------------------

import edsnlp
from pathlib import Path
from typing import Optional, Dict, Any

__version__ = {__version__}

def load(
    overrides: Optional[Dict[str, Any]] = None,
) -> edsnlp.Pipeline:
    path_outside = Path(__file__).parent / "{artifacts_dir}"
    path_inside = Path(__file__).parent / "{artifacts_dir_inside}"
    path = path_inside if path_inside.exists() else path_outside
    model = edsnlp.load(path, overrides=overrides)
    return model
"""

AUTHOR_REGEX = re.compile(r"(?P<name>.*) <(?P<email>.*)>")


def parse_authors(authors):
    authors = [authors] if isinstance(authors, str) else authors
    return [
        author
        if not isinstance(author, str)
        else dict(AUTHOR_REGEX.match(author).groupdict())
        for author in authors
    ]


def replace_with_dict(content: str, replacements: dict):
    # Replace HTML elements with the corresponding values from the dictionary
    for key, replacement in replacements.items():
        # Create a regex pattern to find HTML elements with the given id
        content = re.sub(key, replacement, content, flags=re.DOTALL)
    return content


class Packager:
    def __init__(
        self,
        *,
        name: ModuleName,
        pyproject: Optional[Dict[str, Any]],
        pipeline: Union[Path, "edsnlp.Pipeline"],
        version: Optional[str],
        root_dir: Path = ".",
        build_dir: Optional[Path] = None,
        dist_dir: Path,
        artifacts_name: ModuleName,
        metadata: Optional[Dict[str, Any]] = {},
        exclude: AsList[str],
        readme_replacements: Dict[str, str] = {},
    ):
        try:
            version = version or pyproject["project"]["version"]
        except (KeyError, TypeError):
            version = "0.1.0"
        name = name or pyproject["project"]["name"]
        if pyproject is not None:
            main_package = snake_case(pyproject["project"]["name"].lower())
        else:
            main_package = None
        model_package = snake_case(name.lower())

        root_dir = root_dir.resolve()
        dist_dir = dist_dir if Path(dist_dir).is_absolute() else root_dir / dist_dir

        build_dir = Path(tempfile.mkdtemp()) if build_dir is None else build_dir

        new_pyproject: confit.Config = confit.Config()
        if pyproject is not None:
            new_pyproject["project"] = pyproject["project"]
        new_pyproject = new_pyproject.merge(
            {
                "build-system": {
                    "requires": ["hatchling"],
                    "build-backend": "hatchling.build",
                },
                "tool": {"hatch": {"build": {}}},
                "project": {
                    "name": model_package,
                    "version": version,
                    "requires-python": ">=3.7",
                },
            }
        )

        try:
            find = dict(pyproject["tool"].pop("setuptools", {})["packages"]["find"])
        except Exception:
            find = {}
        where = find.pop("where", ["."])
        where = [where] if not isinstance(where, list) else where
        packages = {main_package, model_package}
        for w in where:
            # TODO Should we handle namespaces ?
            # if find.pop("namespace", None) is not None:
            #     packages.extend(setuptools.find_namespace_packages(**find))
            packages.update(setuptools.find_packages(w, **find))
        packages = sorted([p for p in packages if p])
        file_paths = []
        for package in packages:
            for path in (root_dir / package).rglob("*"):
                if "__pycache__" in path.parts or path.is_dir():
                    continue
                file_paths.append(path)

        new_pyproject["tool"]["hatch"]["build"] = {
            "packages": [*packages, artifacts_name],
            "exclude": ["__pycache__/", "*.pyc", "*.pyo", ".ipynb_checkpoints"],
            "artifacts": [artifacts_name],
            "targets": {
                "wheel": {
                    "sources": {
                        f"{artifacts_name}": f"{model_package}/{artifacts_name}"
                    },
                },
            },
        }

        if "authors" in metadata:
            metadata["authors"] = parse_authors(metadata["authors"])
        metadata["name"] = model_package
        metadata["version"] = version

        pyproject = new_pyproject.merge({"project": metadata})

        self.name = model_package
        self.version = version
        assert model_package == pyproject["project"]["name"]
        assert version == pyproject["project"]["version"]
        self.root_dir = root_dir.resolve()
        self.pipeline = pipeline
        self.artifacts_name = artifacts_name
        self.dist_dir = (
            dist_dir if Path(dist_dir).is_absolute() else self.root_dir / dist_dir
        )
        self.build_dir = build_dir
        self.readme_replacements = readme_replacements
        self.exclude = exclude
        self.file_paths = file_paths
        self.pyproject = pyproject

        logger.info(f"root_dir: {root_dir}")
        logger.info(f"artifacts_name: {artifacts_name}")
        logger.info(f"name: {model_package}")

    def build(
        self,
        distributions: Sequence[str] = (),
        config_settings: Optional[build.ConfigSettingsType] = None,
        isolation: bool = True,
        skip_dependency_check: bool = False,
    ):
        logger.info("Building package")

        if distributions:
            build_call = build_package
        else:
            build_call = build_package_via_sdist
            distributions = ["wheel"]
        build_call(  # type: ignore
            srcdir=self.build_dir,
            outdir=self.dist_dir,
            distributions=distributions,
            config_settings=config_settings,
            isolation=isolation,
            skip_dependency_check=skip_dependency_check,
        )

    def make_src_dir(self):
        snake_name = snake_case(self.name.lower())
        package_dir = self.build_dir / snake_name

        shutil.rmtree(package_dir, ignore_errors=True)
        os.makedirs(package_dir, exist_ok=True)
        build_artifacts_dir = self.build_dir / self.artifacts_name
        for file_path in self.file_paths:
            dest_path = self.build_dir / Path(file_path).relative_to(self.root_dir)
            if isinstance(self.pipeline, Path) and self.pipeline in file_path.parents:
                raise Exception(
                    f"Pipeline ({self.artifacts_name}) is already "
                    "included in the package's data, you should "
                    "remove it from the pyproject.toml metadata."
                )
            os.makedirs(dest_path.parent, exist_ok=True)
            shutil.copy(file_path, dest_path)

        # self.update_pyproject()

        # Write pyproject.toml
        (self.build_dir / "pyproject.toml").write_text(toml.dumps(self.pyproject))
        if "readme" in self.pyproject["project"]:
            readme = (self.root_dir / self.pyproject["project"]["readme"]).read_text()
            readme = replace_with_dict(readme, self.readme_replacements)
            (self.build_dir / "README.md").write_text(readme)

        if isinstance(self.pipeline, Path):
            # self.pipeline = edsnlp.load(self.pipeline)
            shutil.copytree(
                self.pipeline,
                build_artifacts_dir,
            )
        else:
            self.pipeline.to_disk(build_artifacts_dir, exclude=set())

        # After building wheel, artifacts will be placed inside the
        # package dir, not next to it as in source distribution so
        # we let the load script test both locations
        with open(package_dir / "__init__.py", mode="a") as f:
            f.write(
                INIT_PY.format(
                    __version__=repr(self.version),
                    artifacts_dir=os.path.relpath(build_artifacts_dir, package_dir),
                    artifacts_dir_inside=self.artifacts_name,
                )
            )

        # Print all the files that will be included in the package
        for file in self.build_dir.rglob("*"):
            if file.is_file():
                rel = file.relative_to(self.build_dir)
                if not any(rel.match(e) for e in self.exclude):
                    logger.info(f"INCLUDE {rel}")
                else:
                    file.unlink()
                    logger.info(f"SKIP {rel}")


@app.command(name="package")
def package(
    pipeline: Union[Path, "edsnlp.Pipeline"],
    *,
    name: Optional[ModuleName] = None,
    root_dir: Path = Path("."),
    build_dir: Optional[Path] = None,
    dist_dir: Path = Path("dist"),
    artifacts_name: ModuleName = "artifacts",
    check_dependencies: bool = False,
    project_type: Optional[Literal["poetry", "setuptools"]] = None,
    version: Optional[str] = None,
    metadata: Optional[Dict[str, Any]] = {},
    distributions: Optional[AsList[Literal["wheel", "sdist"]]] = ["wheel"],
    config_settings: Optional[Mapping[str, Union[str, Sequence[str]]]] = None,
    isolation: bool = True,
    skip_build_dependency_check: bool = False,
    exclude: Optional[AsList[str]] = None,
    readme_replacements: Dict[str, str] = {},
):
    """

    Parameters
    ----------

    Returns
    -------

    """
    if project_type is not None:
        warnings.warn(
            "Project_type is deprecated, only PEP621 pyproject.toml is supported",
            DeprecationWarning,
        )
    exclude = exclude or ["artifacts/vocab/*"]
    pyproject_path = root_dir / "pyproject.toml"

    if not pyproject_path.exists():
        check_dependencies = True
        if name is None:
            raise ValueError(
                f"No pyproject.toml could be found in the root directory {root_dir}, "
                f"you need to create one, or fill the name parameter."
            )

    if check_dependencies:
        warnings.warn("check_dependencies is deprecated", DeprecationWarning)

    root_dir = root_dir.resolve()

    pyproject = None
    if pyproject_path.exists():
        pyproject = toml.loads((root_dir / "pyproject.toml").read_text())

    packager = Packager(
        pyproject=pyproject,
        pipeline=pipeline,
        name=name,
        version=version,
        root_dir=root_dir,
        build_dir=build_dir,
        dist_dir=dist_dir,
        artifacts_name=artifacts_name,
        metadata=metadata,
        exclude=exclude,
        readme_replacements=readme_replacements,
    )
    packager.make_src_dir()
    packager.build(
        distributions=distributions,
        config_settings=config_settings,
        isolation=isolation,
        skip_dependency_check=skip_build_dependency_check,
    )


if __name__ == "__main__":
    app()
